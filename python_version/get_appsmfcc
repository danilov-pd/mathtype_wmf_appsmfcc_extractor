#!/usr/bin/env python

from kaitaistruct import KaitaiStream, BytesIO
import wmf
from wmf import Wmf
import appsmfcc
from appsmfcc import Appsmfcc
import sys
from dataclasses import dataclass


@dataclass
class FullComment:
    """
    A dataclass to store a comment assembled from chunks and
    it's state.
    """
    is_xml: bool = False    # whether a comment is xml or not
    total_length: int = 0   # total length of the comment from the first chunk header
    raw_data: bytes = b''   # raw comment bytes

if __name__ == '__main__':
    
    if len(sys.argv) != 2:
        print(f'Wrong number of arguments.', file=sys.stderr)
        sys.exit(1)

    input_filename = sys.argv[1]

    appsmfcc_raw = []       # raw appsmfcc comments from WMF's MFCOMMENT data 
    full_comments = []      # list of FullComment objects
    full_comment = None     # current FullComment object

    # read WMF from file
    with Wmf.from_file(input_filename) as data:
        for record in data.records:
            mfcomment_bytes = b'\x0f\x00'
            # check whether the record is escape type with MFCOMMENT inside
            if record.function == Wmf.Func.escape and record.params.startswith(mfcomment_bytes):
                # if the record has AppsMFFC at needed position, append it 
                # to the appsmfcc_raw record list starting from 'AppsMFCC' bytes.  
                if len(record.params) >= 12:
                    appsmfcc_id = record.params[4:12]
                    if appsmfcc_id == b'AppsMFCC':
                        appsmfcc_raw.append(record.params[4:])

    # is xml check; just checks the first bytes 
    # of the comment, doesn't validate the whole thing
    is_xml_check = lambda cmnt : True if cmnt.chunk_data.startswith(b'<?xml version') else False

    for i, comment_raw in enumerate(appsmfcc_raw):
        try:
            comment = Appsmfcc(KaitaiStream(BytesIO(comment_raw))) 
        except Exception:
            print(f'Failed parsing AppsMFCC Comment {i}.', file=sys.stderr)
            continue

        print(f'Comment {i}.', file=sys.stderr)
        print('header:', file=sys.stderr)
        print(f'  id = {comment.header.id}', file=sys.stderr)
        print(f'  version = {comment.header.version}', file=sys.stderr)
        print(f'  total_length = {comment.header.total_length}', file=sys.stderr)
        print(f'  data_length = {comment.header.data_length}', file=sys.stderr)
        print(f'  signature = {comment.header.signature}', file=sys.stderr)
        print('chunk_data:', file=sys.stderr)
        print('  ', comment.chunk_data[:min(10, len(comment.chunk_data))].hex(sep=' '), '...', sep='', file=sys.stderr)

        # multi-chunk comment check
        if comment.header.total_length > comment.header.data_length:
            # whether the current chunk is first chunk check
            if full_comment == None:
                full_comment = FullComment(
                    is_xml=is_xml_check(comment), 
                    total_length=comment.header.total_length, 
                    raw_data=comment.chunk_data
                )
            else:
                # ditch the multi-chunk comment completely if the total_length
                # is inconsistent between the chunks
                if comment.header.total_length != full_comment.total_length:
                    full_comment = None
                    print(f'Ditched the multi-chunk comment at Comment {i}. Total length inconsistency.', file=sys.stderr)
                    pass 
                # otherwise append the chunk to raw_data
                full_comment.raw_data += comment.chunk_data
                # if we are full
                if len(full_comment.raw_data) >= full_comment.total_length:
                    full_comments.append(full_comment)
                    full_comment = None
        else:
            # single-chunk comment branch
            # we don't need to check for total_length < data_length explicitly;
            # that check is already in kaitai description
            full_comment = FullComment(
                is_xml=is_xml_check(comment), 
                total_length=comment.header.total_length, 
                raw_data=comment.chunk_data
            )
            full_comments.append(full_comment)
            full_comment = None

    # write out our comments in respective files with right extensions
    for i, comment in enumerate(full_comments):
        ext = 'xml' if comment.is_xml else 'bin'
        output_filename = f'{input_filename}-appsmfcc-{i}.{ext}' 

        with open(output_filename, 'wb') as of:
            of.write(comment.raw_data)

        print(f'Written comment in \'{output_filename}\'.', file=sys.stderr)

